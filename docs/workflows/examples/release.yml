# Release Automation Workflow
# File: .github/workflows/release.yml
# Description: Automated release process with semantic versioning, changelog generation, and multi-platform distribution

name: Release

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    types: [closed]
    branches:
      - main
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
          - prerelease
      skip_tests:
        description: 'Skip tests'
        required: false
        type: boolean
        default: false
      dry_run:
        description: 'Dry run mode'
        required: false
        type: boolean
        default: false

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: write
  packages: write
  pull-requests: read
  security-events: write
  id-token: write  # For OIDC
  attestations: write  # For provenance

jobs:
  validate:
    name: Pre-release Validation
    runs-on: ubuntu-latest
    outputs:
      should-release: ${{ steps.check.outputs.should-release }}
      release-type: ${{ steps.check.outputs.release-type }}
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Check release conditions
        id: check
        run: |
          # Check if this is a release-triggering event
          should_release="false"
          release_type="auto"
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            should_release="true"
            release_type="${{ github.event.inputs.release_type }}"
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            # Check if this is a merge commit (not a direct push)
            if git log --oneline -1 --pretty=format:"%s" | grep -E "^Merge pull request|^feat|^fix|^perf|^BREAKING CHANGE"; then
              should_release="true"
            fi
          elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.action }}" == "closed" && "${{ github.event.pull_request.merged }}" == "true" ]]; then
            # PR was merged to main
            should_release="true"
          fi
          
          echo "should-release=$should_release" >> $GITHUB_OUTPUT
          echo "release-type=$release_type" >> $GITHUB_OUTPUT
          
          echo "Should release: $should_release"
          echo "Release type: $release_type"

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.should-release == 'true' && github.event.inputs.skip_tests != 'true'
    
    strategy:
      matrix:
        python-version: ['3.9', '3.10', '3.11']
        
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
          
      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -e ".[dev,test]"
          
      - name: Run linting
        run: |
          make lint
          
      - name: Run type checking
        run: |
          make typecheck
          
      - name: Run tests with coverage
        run: |
          make coverage
          
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          
      - name: Run security scanning
        run: |
          make security

  build:
    name: Build Artifacts
    runs-on: ubuntu-latest
    needs: [validate, test]
    if: needs.validate.outputs.should-release == 'true' && (success() || github.event.inputs.skip_tests == 'true')
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          
      - name: Install build dependencies
        run: |
          pip install --upgrade pip
          pip install build twine setuptools wheel
          
      - name: Get version
        id: version
        run: |
          # Get version from pyproject.toml or calculate next version
          if [[ "${{ needs.validate.outputs.release-type }}" == "auto" ]]; then
            # Use semantic-release to determine version
            npx semantic-release --dry-run --no-ci | grep "next release version" | awk '{print $NF}' > next_version.txt
            version=$(cat next_version.txt || echo "0.0.0")
          else
            # Manual version bump
            current_version=$(python -c "import toml; print(toml.load('pyproject.toml')['project']['version'])")
            case "${{ needs.validate.outputs.release-type }}" in
              "patch")
                version=$(echo $current_version | awk -F. '{print $1"."$2"."$3+1}')
                ;;
              "minor")
                version=$(echo $current_version | awk -F. '{print $1"."$2+1".0"}')
                ;;
              "major")
                version=$(echo $current_version | awk -F. '{print $1+1".0.0"}')
                ;;
              "prerelease")
                version="${current_version}-rc.${GITHUB_RUN_NUMBER}"
                ;;
            esac
          fi
          
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "Building version: $version"
          
          # Update version in pyproject.toml
          sed -i "s/version = \".*\"/version = \"$version\"/" pyproject.toml
          
      - name: Build Python package
        run: |
          python -m build
          
      - name: Verify package
        run: |
          twine check dist/*
          
      - name: Upload Python artifacts
        uses: actions/upload-artifact@v3
        with:
          name: python-package
          path: dist/
          retention-days: 30

  build-docker:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [validate, build]
    if: needs.validate.outputs.should-release == 'true'
    
    strategy:
      matrix:
        platform: [amd64, arm64]
        
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}},value=${{ needs.build.outputs.version }}
            type=semver,pattern={{major}}.{{minor}},value=${{ needs.build.outputs.version }}
            type=semver,pattern={{major}},value=${{ needs.build.outputs.version }}
            type=raw,value=latest,enable={{is_default_branch}}
            
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/${{ matrix.platform }}
          push: ${{ github.event.inputs.dry_run != 'true' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ needs.build.outputs.version }}
            BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VCS_REF=${{ github.sha }}
            
      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.version }}
          format: spdx-json
          output-file: sbom-${{ matrix.platform }}.spdx.json
          
      - name: Upload SBOM
        uses: actions/upload-artifact@v3
        with:
          name: sbom-${{ matrix.platform }}
          path: sbom-${{ matrix.platform }}.spdx.json
          
      - name: Scan image for vulnerabilities
        uses: anchore/scan-action@v3
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.version }}
          fail-build: true
          severity-cutoff: high

  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: [build-docker]
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.version }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          
      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
          
      - name: Generate security report
        run: |
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy image --format json --output security-report.json \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.version }}
            
      - name: Upload security report
        uses: actions/upload-artifact@v3
        with:
          name: security-report
          path: security-report.json

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [validate, build, build-docker, security-scan]
    if: needs.validate.outputs.should-release == 'true' && github.event.inputs.dry_run != 'true'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          
      - name: Install semantic-release
        run: |
          npm install -g semantic-release @semantic-release/changelog @semantic-release/git @semantic-release/github @semantic-release/exec
          
      - name: Download Python artifacts
        uses: actions/download-artifact@v3
        with:
          name: python-package
          path: dist/
          
      - name: Download SBOM artifacts
        uses: actions/download-artifact@v3
        with:
          pattern: sbom-*
          merge-multiple: true
          
      - name: Download security report
        uses: actions/download-artifact@v3
        with:
          name: security-report
          
      - name: Create release
        if: needs.validate.outputs.release-type == 'auto'
        run: |
          semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Create manual release
        if: needs.validate.outputs.release-type != 'auto'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const version = '${{ needs.build.outputs.version }}';
            
            // Generate release notes
            const { execSync } = require('child_process');
            const lastTag = execSync('git describe --tags --abbrev=0 HEAD^', { encoding: 'utf8' }).trim();
            const commits = execSync(`git log ${lastTag}..HEAD --pretty=format:"- %s (%h)"`, { encoding: 'utf8' }).trim();
            
            const releaseNotes = `
            ## What's Changed
            
            ${commits}
            
            ## Docker Images
            
            \`\`\`bash
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${version}
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            \`\`\`
            
            ## Installation
            
            \`\`\`bash
            pip install docker-optimizer-agent==${version}
            \`\`\`
            
            ## Security
            
            - All images scanned for vulnerabilities
            - SBOM (Software Bill of Materials) included
            - Security report available in assets
            
            **Full Changelog**: https://github.com/${{ github.repository }}/compare/${lastTag}...v${version}
            `;
            
            // Create release
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: `v${version}`,
              name: `Release v${version}`,
              body: releaseNotes,
              draft: false,
              prerelease: version.includes('-'),
              generate_release_notes: true
            });
            
            // Upload assets
            const glob = require('glob');
            
            // Upload Python packages
            const pythonAssets = glob.sync('dist/*');
            for (const asset of pythonAssets) {
              const name = asset.split('/').pop();
              const data = fs.readFileSync(asset);
              
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                name: name,
                data: data
              });
            }
            
            // Upload SBOM files
            const sbomAssets = glob.sync('sbom-*.spdx.json');
            for (const asset of sbomAssets) {
              const name = asset.split('/').pop();
              const data = fs.readFileSync(asset);
              
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                name: name,
                data: data
              });
            }
            
            // Upload security report
            if (fs.existsSync('security-report.json')) {
              const data = fs.readFileSync('security-report.json');
              
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                name: 'security-report.json',
                data: data
              });
            }

  publish-pypi:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: [create-release]
    if: github.ref == 'refs/heads/main' && github.event.inputs.dry_run != 'true'
    environment: release
    
    steps:
      - name: Download Python artifacts
        uses: actions/download-artifact@v3
        with:
          name: python-package
          path: dist/
          
      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_API_TOKEN }}
          verify-metadata: true
          skip-existing: true
          
      - name: Verify PyPI publication
        run: |
          sleep 60  # Wait for PyPI to process
          pip install docker-optimizer-agent==${{ needs.build.outputs.version }}
          python -c "import docker_optimizer; print(f'Successfully installed version {docker_optimizer.__version__}')"

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [create-release]
    environment: staging
    
    steps:
      - name: Deploy to staging environment
        run: |
          # This would typically involve:
          # - Updating Kubernetes manifests
          # - Rolling out to staging cluster
          # - Running smoke tests
          echo "Deploying to staging environment"
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.version }}"
          
          # Example Kubernetes deployment
          # kubectl set image deployment/docker-optimizer \
          #   docker-optimizer=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.version }}
          # kubectl rollout status deployment/docker-optimizer
          
      - name: Run smoke tests
        run: |
          # Run basic smoke tests against staging
          echo "Running smoke tests..."
          # curl -f https://staging.example.com/health
          # curl -f https://staging.example.com/metrics

  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [create-release, publish-pypi, deploy-staging]
    if: always()
    
    steps:
      - name: Send Slack notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          custom_payload: |
            {
              text: "${{ job.status == 'success' && '✅' || '❌' }} Release ${{ needs.build.outputs.version }} - ${{ job.status }}",
              attachments: [
                {
                  color: "${{ job.status == 'success' && 'good' || 'danger' }}",
                  fields: [
                    {
                      title: "Version",
                      value: "${{ needs.build.outputs.version }}",
                      short: true
                    },
                    {
                      title: "Repository",
                      value: "${{ github.repository }}",
                      short: true
                    },
                    {
                      title: "Release",
                      value: "<${{ github.server_url }}/${{ github.repository }}/releases/tag/v${{ needs.build.outputs.version }}|View Release>",
                      short: false
                    },
                    {
                      title: "Docker Image",
                      value: "`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.version }}`",
                      short: false
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          
      - name: Send email notification
        if: failure()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: "❌ Release Failed: ${{ github.repository }} v${{ needs.build.outputs.version }}"
          body: |
            Release pipeline failed for ${{ github.repository }} version ${{ needs.build.outputs.version }}.
            
            Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            
            Please investigate and resolve the issues.
          to: ${{ secrets.NOTIFICATION_EMAIL }}
          from: "GitHub Actions <noreply@github.com>"